<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PKN2503407-B</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      width: 100%;
      overflow-x: hidden;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: #ffffff;
      color: #111;
    }

    /* ì˜¤ë²„ë ˆì´ ì—´ë¦° ë™ì•ˆ ë°°ê²½ ìŠ¤í¬ë¡¤ ë°©ì§€ */
    body.lock {
      overflow: hidden;
      height: 100vh;
      touch-action: none;
    }

    .wrap {
      max-width: 520px;
      margin: 0 auto;
      padding: 26px 18px 30px;
      text-align: center;
    }

    h1 {
      margin: 22px 0 26px;
      font-size: 44px;
      font-weight: 700;
      color: #555;
    }

    .sub {
      font-size: 18px;
      font-weight: 600;
      color: #555;
      line-height: 1.4;
      margin-bottom: 30px;
    }

    /* ì¸ë„¤ì¼ ê·¸ë¦¬ë“œ */
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    .thumb {
      border: 2px solid #bcbcbc;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      cursor: pointer;
      background: #f5f5f5;
    }

    .thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* Overlay */
    .overlay {
      position: fixed;
      inset: 0;
      background: white;
      display: none;
      z-index: 9999;

      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }
    .overlay.show { display: block; }

    /* ìƒë‹¨ ë²„íŠ¼ ì˜ì—­ */
    .topbar {
      position: sticky;
      top: 0;
      padding: 12px 16px; /* ê¸°ë³¸(ì›¹) */
      display: flex;
      justify-content: space-between;
      z-index: 10;

      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(6px);
    }

    .btn {
      border: 1px solid #ccc;
      background: #fff;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
    }

    /* Viewer */
    .viewer {
      min-height: 100vh;  /* fallback */
      min-height: 100svh; /* ëª¨ë°”ì¼ ì•ˆì „ */
      min-height: 100dvh; /* ìµœì‹  ëª¨ë°”ì¼ ë™ì  ë·°í¬íŠ¸ */

      width: 100%;
      display: grid;
      place-items: center;
      overflow: visible;
      user-select: none;
      box-sizing: border-box;

      padding: 6px 0 18px; /* â­ ìµœì¢… ê°„ê²© */

      /* âœ… í™•ëŒ€/ì´ë™ì„ ìœ„í•´ */
      touch-action: pan-y pinch-zoom;
    }

    /* ì´ë¯¸ì§€: ê·¸ëŒ€ë¡œ contain */
    .viewer img {
      max-width: 100%;
      height: auto;
      width: auto;
      object-fit: contain;
      display: block;

      pointer-events: auto;
      -webkit-user-drag: none;

      transform-origin: center center;
      will-change: transform;
      user-select: none;
      -webkit-user-select: none;
    }

    /* âœ… ë¹„ë””ì˜¤: contain ìœ ì§€ + ê²€ì€ í…Œë‘ë¦¬(ë ˆí„°ë°•ìŠ¤) í°ìƒ‰ ì²˜ë¦¬ */
    .viewer video {
      max-width: 100%;
      height: auto;
      width: auto;
      object-fit: contain;
      display: block;

      background: #fff;        /* ğŸ”¥ ë‚¨ëŠ” ì˜ì—­ í°ìƒ‰ */
      outline: none;
      border: 0;

      pointer-events: auto;
      -webkit-user-drag: none;

      transform-origin: center center;
      will-change: transform;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ëª¨ë°”ì¼ ìµœì í™” + ëª¨ë°”ì¼ì—ì„œë§Œ ìœ„ë¡œ ì˜¬ë¦¬ê¸° */
    @media (max-width: 768px) {
      .topbar {
        padding-top: calc(8px + env(safe-area-inset-top));
        padding-right: 12px;
        padding-left: 12px;
        padding-bottom: 8px;
      }

      .viewer {
        place-items: start center; /* âœ… ëª¨ë°”ì¼ì—ì„œë§Œ ì¤‘ì•™ì„ ìœ„ë¡œ */
        padding-top: 8px;         /* ë„ˆë¬´ ë”± ë¶™ì§€ ì•Šê²Œ */
        padding-bottom: 12px;
      }

      .btn {
        padding: 8px 12px;
        border-radius: 10px;
      }
    }

    .tp-logo {
      margin-top: 14px;
      display: flex;
      justify-content: flex-end;
    }

    .tp-logo img {
      width: 44px;
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>PKN2503407-B</h1>

    <div class="sub">
      Woven - Plain Weave<br>
      Nylon 96% Span 4%<br>
      240(g/mÂ²) / 7.08(oz)<br>
      Piece Dye
    </div>

    <div class="grid">
      <div class="thumb" data-type="image" data-src="2.png"><img src="1.png" alt=""></div>
      <div class="thumb" data-type="image" data-src="4.png"><img src="3.png" alt=""></div>
      <div class="thumb" data-type="video" data-src="6.mp4"><img src="5.png" alt=""></div>
      <div class="thumb" data-type="image" data-src="8.png"><img src="7.png" alt=""></div>
    </div>

    <div class="tp-logo">
      <img src="./tp-logo.png" alt="TP Logo">
    </div>
  </div>

  <!-- Overlay Viewer -->
  <div class="overlay" id="overlay">
    <div class="topbar">
      <button class="btn" id="backBtn">â† Back</button>
      <button class="btn" id="closeBtn">Close âœ•</button>
    </div>
    <div class="viewer" id="viewer"></div>
  </div>

  <script>
    const overlay = document.getElementById("overlay");
    const viewer = document.getElementById("viewer");
    const backBtn = document.getElementById("backBtn");
    const closeBtn = document.getElementById("closeBtn");
    const thumbs = Array.from(document.querySelectorAll(".thumb"));

    let currentIndex = 0;

    // âœ… í™•ëŒ€ ìƒíƒœ
    let activeMedia = null; // img or video
    let scale = 1;
    let translateX = 0;
    let translateY = 0;

    // í•€ì¹˜ ì¤Œ ìƒíƒœ
    let pinchStartDist = 0;
    let pinchStartScale = 1;
    let isPinching = false;

    // ë“œë˜ê·¸(ì´ë™) ìƒíƒœ (í™•ëŒ€ ìƒíƒœì—ì„œë§Œ)
    let dragStartX = 0;
    let dragStartY = 0;
    let dragOriginX = 0;
    let dragOriginY = 0;
    let isDragging = false;

    // ë”ë¸”íƒ­
    let lastTapTime = 0;

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function applyTransform() {
      if (!activeMedia) return;
      activeMedia.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    function resetZoom() {
      scale = 1;
      translateX = 0;
      translateY = 0;
      applyTransform();
    }

    function setActiveMedia(el) {
      activeMedia = el;
      resetZoom();
    }

    function showMedia(index) {
      const n = thumbs.length;
      currentIndex = ((index % n) + n) % n;

      viewer.innerHTML = "";
      activeMedia = null;

      const el = thumbs[currentIndex];
      const type = el.dataset.type;
      const src = el.dataset.src;

      if (type === "video") {
        const video = document.createElement("video");
        video.src = src;
        video.autoplay = true;
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.controls = false;
        video.preload = "metadata";
        viewer.appendChild(video);

        const p = video.play();
        if (p && typeof p.catch === "function") p.catch(() => {});

        // ë¹„ë””ì˜¤ë„ í™•ëŒ€ í—ˆìš©(ì›ì¹˜ ì•Šìœ¼ë©´ ì´ ì¤„ ì œê±°)
        setActiveMedia(video);
      } else {
        const img = document.createElement("img");
        img.src = src;
        viewer.appendChild(img);
        setActiveMedia(img);
      }

      overlay.scrollTop = 0;
    }

    function openViewer(index) {
      showMedia(index);
      overlay.classList.add("show");
      document.body.classList.add("lock");
      history.pushState({ open: true }, "");
    }

    function closeViewer() {
      overlay.classList.remove("show");
      viewer.innerHTML = "";
      document.body.classList.remove("lock");
    }

    function next() { showMedia(currentIndex + 1); }
    function prev() { showMedia(currentIndex - 1); }

    thumbs.forEach((el, i) => el.addEventListener("click", () => openViewer(i)));

    backBtn.addEventListener("click", () => history.back());
    closeBtn.addEventListener("click", () => history.back());

    window.addEventListener("popstate", () => {
      if (overlay.classList.contains("show")) closeViewer();
    });

    /* âœ… ìŠ¤ì™€ì´í”„ ê¸°ëŠ¥ ì œê±°ë¨
       - í•€ì¹˜ì¤Œ + ë”ë¸”íƒ­ì¤Œ + (í™•ëŒ€ ì‹œ) ë“œë˜ê·¸ ì´ë™ë§Œ ì œê³µ
       - íƒ­ìœ¼ë¡œ ì¢Œ/ìš° ë„˜ê¹€ì€ ìœ ì§€(ë‹¨, í™•ëŒ€ ì¤‘ì—ëŠ” ë¹„í™œì„±)
    */

    function onDoubleTap(clientX, clientY) {
      if (!activeMedia) return;

      const rect = activeMedia.getBoundingClientRect();
      const cx = clientX - rect.left - rect.width / 2;
      const cy = clientY - rect.top - rect.height / 2;

      if (scale === 1) {
        scale = 2.5;
        translateX = -cx * (scale - 1);
        translateY = -cy * (scale - 1);
      } else {
        resetZoom();
      }
      applyTransform();
    }

    // í´ë¦­(íƒ­) ë„¤ë¹„ê²Œì´ì…˜: í™•ëŒ€(>1) ìƒíƒœë©´ ë„˜ê¸°ì§€ ì•ŠìŒ
    viewer.addEventListener("click", (e) => {
      if (!overlay.classList.contains("show")) return;
      if (scale > 1.01) return;

      const rect = viewer.getBoundingClientRect();
      const x = e.clientX - rect.left;
      if (x < rect.width / 2) prev();
      else next();
    });

    // Touch: í•€ì¹˜ ì¤Œ + ë”ë¸”íƒ­
    viewer.addEventListener("touchstart", (e) => {
      if (!overlay.classList.contains("show")) return;
      if (!activeMedia) return;

      const now = Date.now();

      if (e.touches.length === 1) {
        // ë”ë¸”íƒ­ ê°ì§€
        if (now - lastTapTime < 280) {
          const t = e.touches[0];
          onDoubleTap(t.clientX, t.clientY);
          lastTapTime = 0;
          return;
        }
        lastTapTime = now;

        // í™•ëŒ€ ìƒíƒœì—ì„œë§Œ ë“œë˜ê·¸ ì´ë™ ì‹œì‘
        if (scale > 1.01) {
          isDragging = true;
          const t = e.touches[0];
          dragStartX = t.clientX;
          dragStartY = t.clientY;
          dragOriginX = translateX;
          dragOriginY = translateY;
        }
      }

      // í•€ì¹˜ ì‹œì‘
      if (e.touches.length === 2) {
        isPinching = true;
        const [a, b] = e.touches;
        pinchStartDist = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
        pinchStartScale = scale;
      }
    }, { passive: true });

    viewer.addEventListener("touchmove", (e) => {
      if (!overlay.classList.contains("show")) return;
      if (!activeMedia) return;

      // í•€ì¹˜ ì¤‘ì´ë©´ ìŠ¤í¬ë¡¤ ë°©ì§€í•˜ê³  í™•ëŒ€
      if (isPinching && e.touches.length === 2) {
        e.preventDefault();
        const [a, b] = e.touches;
        const dist = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
        scale = clamp(pinchStartScale * (dist / pinchStartDist), 1, 5);
        applyTransform();
        return;
      }

      // í™•ëŒ€ ìƒíƒœ ë“œë˜ê·¸ ì´ë™
      if (isDragging && e.touches.length === 1 && scale > 1.01) {
        e.preventDefault();
        const t = e.touches[0];
        translateX = dragOriginX + (t.clientX - dragStartX);
        translateY = dragOriginY + (t.clientY - dragStartY);
        applyTransform();
      }
    }, { passive: false });

    viewer.addEventListener("touchend", () => {
      isPinching = false;
      isDragging = false;
      if (scale < 1.01) resetZoom();
    }, { passive: true });

    viewer.addEventListener("touchcancel", () => {
      isPinching = false;
      isDragging = false;
      if (scale < 1.01) resetZoom();
    }, { passive: true });

    // Mouse: ë”ë¸”í´ë¦­ ì¤Œ + (í™•ëŒ€ ì‹œ) ë“œë˜ê·¸ ì´ë™
    viewer.addEventListener("dblclick", (e) => {
      if (!overlay.classList.contains("show")) return;
      onDoubleTap(e.clientX, e.clientY);
    });

    viewer.addEventListener("mousedown", (e) => {
      if (!overlay.classList.contains("show")) return;
      if (!activeMedia) return;
      if (scale <= 1.01) return;

      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragOriginX = translateX;
      dragOriginY = translateY;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      translateX = dragOriginX + (e.clientX - dragStartX);
      translateY = dragOriginY + (e.clientY - dragStartY);
      applyTransform();
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      if (scale < 1.01) resetZoom();
    });
  </script>
</body>
</html>
